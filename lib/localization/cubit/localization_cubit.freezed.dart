// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'localization_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$LocalizationState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() getCurrent,
    required TResult Function() toAr,
    required TResult Function() toEn,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? getCurrent,
    TResult? Function()? toAr,
    TResult? Function()? toEn,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? getCurrent,
    TResult Function()? toAr,
    TResult Function()? toEn,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_GetCurrent value) getCurrent,
    required TResult Function(_ToAr value) toAr,
    required TResult Function(_ToEn value) toEn,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_GetCurrent value)? getCurrent,
    TResult? Function(_ToAr value)? toAr,
    TResult? Function(_ToEn value)? toEn,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_GetCurrent value)? getCurrent,
    TResult Function(_ToAr value)? toAr,
    TResult Function(_ToEn value)? toEn,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocalizationStateCopyWith<$Res> {
  factory $LocalizationStateCopyWith(
          LocalizationState value, $Res Function(LocalizationState) then) =
      _$LocalizationStateCopyWithImpl<$Res, LocalizationState>;
}

/// @nodoc
class _$LocalizationStateCopyWithImpl<$Res, $Val extends LocalizationState>
    implements $LocalizationStateCopyWith<$Res> {
  _$LocalizationStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$LocalizationStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl with DiagnosticableTreeMixin implements _Initial {
  const _$InitialImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalizationState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'LocalizationState.initial'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() getCurrent,
    required TResult Function() toAr,
    required TResult Function() toEn,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? getCurrent,
    TResult? Function()? toAr,
    TResult? Function()? toEn,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? getCurrent,
    TResult Function()? toAr,
    TResult Function()? toEn,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_GetCurrent value) getCurrent,
    required TResult Function(_ToAr value) toAr,
    required TResult Function(_ToEn value) toEn,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_GetCurrent value)? getCurrent,
    TResult? Function(_ToAr value)? toAr,
    TResult? Function(_ToEn value)? toEn,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_GetCurrent value)? getCurrent,
    TResult Function(_ToAr value)? toAr,
    TResult Function(_ToEn value)? toEn,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements LocalizationState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$GetCurrentImplCopyWith<$Res> {
  factory _$$GetCurrentImplCopyWith(
          _$GetCurrentImpl value, $Res Function(_$GetCurrentImpl) then) =
      __$$GetCurrentImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetCurrentImplCopyWithImpl<$Res>
    extends _$LocalizationStateCopyWithImpl<$Res, _$GetCurrentImpl>
    implements _$$GetCurrentImplCopyWith<$Res> {
  __$$GetCurrentImplCopyWithImpl(
      _$GetCurrentImpl _value, $Res Function(_$GetCurrentImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetCurrentImpl with DiagnosticableTreeMixin implements _GetCurrent {
  const _$GetCurrentImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalizationState.getCurrent()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'LocalizationState.getCurrent'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetCurrentImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() getCurrent,
    required TResult Function() toAr,
    required TResult Function() toEn,
  }) {
    return getCurrent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? getCurrent,
    TResult? Function()? toAr,
    TResult? Function()? toEn,
  }) {
    return getCurrent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? getCurrent,
    TResult Function()? toAr,
    TResult Function()? toEn,
    required TResult orElse(),
  }) {
    if (getCurrent != null) {
      return getCurrent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_GetCurrent value) getCurrent,
    required TResult Function(_ToAr value) toAr,
    required TResult Function(_ToEn value) toEn,
  }) {
    return getCurrent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_GetCurrent value)? getCurrent,
    TResult? Function(_ToAr value)? toAr,
    TResult? Function(_ToEn value)? toEn,
  }) {
    return getCurrent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_GetCurrent value)? getCurrent,
    TResult Function(_ToAr value)? toAr,
    TResult Function(_ToEn value)? toEn,
    required TResult orElse(),
  }) {
    if (getCurrent != null) {
      return getCurrent(this);
    }
    return orElse();
  }
}

abstract class _GetCurrent implements LocalizationState {
  const factory _GetCurrent() = _$GetCurrentImpl;
}

/// @nodoc
abstract class _$$ToArImplCopyWith<$Res> {
  factory _$$ToArImplCopyWith(
          _$ToArImpl value, $Res Function(_$ToArImpl) then) =
      __$$ToArImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToArImplCopyWithImpl<$Res>
    extends _$LocalizationStateCopyWithImpl<$Res, _$ToArImpl>
    implements _$$ToArImplCopyWith<$Res> {
  __$$ToArImplCopyWithImpl(_$ToArImpl _value, $Res Function(_$ToArImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ToArImpl with DiagnosticableTreeMixin implements _ToAr {
  const _$ToArImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalizationState.toAr()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'LocalizationState.toAr'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToArImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() getCurrent,
    required TResult Function() toAr,
    required TResult Function() toEn,
  }) {
    return toAr();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? getCurrent,
    TResult? Function()? toAr,
    TResult? Function()? toEn,
  }) {
    return toAr?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? getCurrent,
    TResult Function()? toAr,
    TResult Function()? toEn,
    required TResult orElse(),
  }) {
    if (toAr != null) {
      return toAr();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_GetCurrent value) getCurrent,
    required TResult Function(_ToAr value) toAr,
    required TResult Function(_ToEn value) toEn,
  }) {
    return toAr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_GetCurrent value)? getCurrent,
    TResult? Function(_ToAr value)? toAr,
    TResult? Function(_ToEn value)? toEn,
  }) {
    return toAr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_GetCurrent value)? getCurrent,
    TResult Function(_ToAr value)? toAr,
    TResult Function(_ToEn value)? toEn,
    required TResult orElse(),
  }) {
    if (toAr != null) {
      return toAr(this);
    }
    return orElse();
  }
}

abstract class _ToAr implements LocalizationState {
  const factory _ToAr() = _$ToArImpl;
}

/// @nodoc
abstract class _$$ToEnImplCopyWith<$Res> {
  factory _$$ToEnImplCopyWith(
          _$ToEnImpl value, $Res Function(_$ToEnImpl) then) =
      __$$ToEnImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToEnImplCopyWithImpl<$Res>
    extends _$LocalizationStateCopyWithImpl<$Res, _$ToEnImpl>
    implements _$$ToEnImplCopyWith<$Res> {
  __$$ToEnImplCopyWithImpl(_$ToEnImpl _value, $Res Function(_$ToEnImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ToEnImpl with DiagnosticableTreeMixin implements _ToEn {
  const _$ToEnImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LocalizationState.toEn()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'LocalizationState.toEn'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToEnImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() getCurrent,
    required TResult Function() toAr,
    required TResult Function() toEn,
  }) {
    return toEn();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? getCurrent,
    TResult? Function()? toAr,
    TResult? Function()? toEn,
  }) {
    return toEn?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? getCurrent,
    TResult Function()? toAr,
    TResult Function()? toEn,
    required TResult orElse(),
  }) {
    if (toEn != null) {
      return toEn();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_GetCurrent value) getCurrent,
    required TResult Function(_ToAr value) toAr,
    required TResult Function(_ToEn value) toEn,
  }) {
    return toEn(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_GetCurrent value)? getCurrent,
    TResult? Function(_ToAr value)? toAr,
    TResult? Function(_ToEn value)? toEn,
  }) {
    return toEn?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_GetCurrent value)? getCurrent,
    TResult Function(_ToAr value)? toAr,
    TResult Function(_ToEn value)? toEn,
    required TResult orElse(),
  }) {
    if (toEn != null) {
      return toEn(this);
    }
    return orElse();
  }
}

abstract class _ToEn implements LocalizationState {
  const factory _ToEn() = _$ToEnImpl;
}
